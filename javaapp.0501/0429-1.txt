**Thread
=>프로세스 내에 만드는 것으로 작업 도중 다른 작업으로 제어권을 넘길 수 있도록 해주는 작업 단위
=>단독으로는 실행할 수 없고 프로세스(Method)내에서 생성해서 실행

=>일반 메소드 호출은 하나의 메소드의 수행이 완료될때까지 다른 메소드의 수행을 할 수 없는 구조입니다.
이러한 방식을 동기식(Synchronized)이라고 합니다.
=>스레드는 하나의 작업이 진행 중인 동안에도 제어권을 다른 스레드로 옮겨서 처리가 가능 합니다.
이러한 방식을 비동기식(asyncronized)이라고 합니다.
=>스레드를 만드는 방식은 거의 대다수 프로그래밍 언어가 비슷하고 해결해야할 문제들도 비슷합니다.


1.생성
1)java.lang.Thread 클래스 이용
=>Thread 클래스로부터 상속받는 클래스를 만들어서 run메소드를 구현
=>클래스의 인스턴스를 생성해서 start()호출
=>Thread 클래스에느 run 메소드 이외의 여러 메소드가 존재


2)java.lang.Runnable 인터페이스를 이용
=>Runnable 인터페이스를 구현한 클래스를 만들어서 run 메소드를 구현
=>클래스의 인스턴스를 생성
=>Thread 클래스의 인스턴스를 생성할때 생성자의 매개변수로 만들어진 인스턴스를 대입
=>Thread 클래스의 인스턴스가 run을 호출
=>Runnable 인터페이스에는 run 메소드만 존재

2. java에서 상속이나 구현하는 방법
1)상속이나 구현한 클래스를 만들고 인스턴스를 생성

2)클래스를 만들지 않고 상속이나 구현한 인스턴스를 생성  - anoymous class



3. Demon Thread
=>Daemon Thread가 아닌 스레드가 없으면 자동으로 종료되는 스레드
=>백그라운드에서 작업하고 있다가 다른 스레드가 종료되면 같이 종료되는 스레드
=>주기적으로 계속해서 해야 하는 작업 중에서 자동으로 종료되면 같은 작업을 만들때 사용 : 응용프로그램에서
주기적으로 하는 자동 저장 기능이나 서버와 클라이언트 시스템에서 데이터 백업 등에 주로 이용

=>start를  호출하기 전에 setDaemon(true)를 호출하면 됩니다.

4. Thread Priority(우선 순위)
=>스레드의 우선 순위 설정
=>우선 순위를 설정하면 스레드의 시작 순서나 동작 횟수를 서로 다르게 설정할 수 있습니다.
=>getPriority 메소드를 이용해서 우선 순위를 정수로 리턴받을 수 있고 setPriority로 우선 순위를 설정할 수 있습니다.
=>우선 순위가 높다고 해서 반드시 먼저 수행하거나 자주 수행되는 것은 아닙니다.
=>우선 순위를 설정할 때 매개변수는 정수인데 정수를 직접 설정하는 것은 바람직하지 않습니다.

Thread 클래스의 Field를 이용하는 것을 권장합니다.
Thread.MAX_PRIORITY, Thread.NORMAI_PRIORITY, Thread.MIN_PRIORITY 등으로 설정
=>MS Windows는 스레드의 우선 순위가 1부터 10까지 이지만 리눅스는 1부터 7까지 입니다.
10이라고 직접 설정하면 Linux에서는 적용이 안됩니다.
Thread.MAX_PRIORITY로 설정하면 Windows에서는 10 Linux에서 7로 설정됩니다.


5.ThreadGroup
=>여러개의 스레드를 묶어주기 위해서 제공하는 클래스
=>리눅스에서 제대로 동작하지 않는 경우가 있어서 실제 사용은 잘 하지 않음
=>List를 이용해서 직접 묶어서 사용합니다.

6. 스레드의 강제 종료
1)Interrupt :다른 작업을 방해하는 것
=>직업 별로 우선순위라는 것이 있어서 우선순위가 높은 직업이 발생시킨 인터럽트만 전달됩니다.

2)강제 종료
=>스레드의 실행 구문에서 InterruptedException이 발생하면 return 하도록 코드를 작성
=>스레드 인스턴스가 interrupt()라는 메소드를 호출하도록 하면 됩니다.

3)되도록이면 스레드를 만들 때 interruptedException이 발생하면 종료하도록 작성하는 것이 좋습니다.
스마트폰의 경우는 InterruptedException이 발생하면 현재 상태를 저장해 두었다가 해결이 되면 이어서 하도록 작성하는
것이 좋습니다.


7. Multiple Exclusion(상호 배제)
=>하나의 스레드가 수정하고 있는 자원을 사용을 끝내기 전에 다른 스레드가 수정할 수 없도록 하는 것
=>Critical Section(임계영역) : 공유자원을 사용하는 코드 영역

1)synchronized method
=>메소드의 결과형 앞에 synchronized를 붙여주면 이 메소드는 수행하고 있는 도중에 다른 스레드에서 제어권을 
넘기지 않습니다.
메소드를 synchronized화 하면 공유도가 떨어집니다.

2)synchronize block
=>공유 자원을 한 번에 사용해야 하는 코드 영역을 synchronized(공유객체){ }로 묶어주는 것  { }안의 코드 영역을 실행할때는
다른 스레드가 공유객체를 사용할 수 없도록 합니다.

3)ReentrantLock 을 이용
=>인스턴스를 만들고 lock()을 호출하면 동기화 출력이 되고 unlock()을 호출하면 해제



8. 생산자와 소비자 문제
=>생산자 스레드는 자원을 생산하고 소비자 스레드는 자원을 소비하는 경우 동시에 수행할 수 잇도록 만들 수 있는데
이 경우에는 생산자 스레드가 자원을 생산하지 않은 상태에서 소비자 스레드가 자원을 소비할려고 하면 예외가 발생해서
소비자 스레드가 종료되어버리는 현상이 발생할 수 있습니다.

=>공유 자원이 없을 때는 소비자 스레드가 중지 상태에 있다가 생산자가 자원을 생성하고 신호를 주면 
작업을 수행하도록 하면 됩니다.

=>작업을 대기하는 것은 wait 메소드를 호출하면 되고 신호를 보내는 것은 notify()와 notifyAll()을 이용합니다.
notify()는 wait 중인 스레드 중에서 하나를 실행시키는 것이고 notifyAll()은 wait중인 모든 스레드를 실행시키는 것입니다.

=>wait 메소드와 notify메소드는 synchronize 메소드에서만 사용이 가능합니다.


9. Semaphore
=>동시에 수행할 스레드의 개수를 설정할 수 있는 클래스
=>ThreadPool :여러 개의 스레드를 미리 만들어두고 빌려서 사용할 수 있도록 해주는 스레드의 집합
=>ThreadPool은 데이터베이스나 서버에서 많이 사용하는데 Semaphore를 이용해서 구현 가능

**연습문제!!**

{20, 19, 76, 87, 22} : 거리가 가장 가까운 2개의 숫자 조합을 찾아내서 출력






